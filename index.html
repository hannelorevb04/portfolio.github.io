<!DOCTYPE html>
<html lang="nl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Portfolio Clapper — Three.js</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #0c1e2f;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.161.0/build/three.module.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js";

      // renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(innerWidth, innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);

      // scene & camera
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0c1e2f);
      const camera = new THREE.PerspectiveCamera(
        50,
        innerWidth / innerHeight,
        0.1,
        100
      );
      camera.position.set(2.2, 1.3, 3.2);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.target.set(0, 0.65, 0);

      // lights
      scene.add(new THREE.HemisphereLight(0xddeeff, 0x223344, 0.8));
      const key = new THREE.DirectionalLight(0xffffff, 1.6);
      key.position.set(3, 6, 4);
      key.castShadow = true;
      scene.add(key);

      // ground
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(20, 20),
        new THREE.MeshStandardMaterial({ color: 0x0e2740, roughness: 0.9 })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // === Helper textures ===
      function noiseTex(w = 256, h = 256, c = 1.4) {
        const cnv = document.createElement("canvas");
        cnv.width = w;
        cnv.height = h;
        const ctx = cnv.getContext("2d"),
          img = ctx.createImageData(w, h);
        for (let i = 0; i < img.data.length; i += 4) {
          const v = Math.pow(Math.random(), c) * 255;
          img.data[i] = img.data[i + 1] = img.data[i + 2] = v;
          img.data[i + 3] = 255;
        }
        ctx.putImageData(img, 0, 0);
        return new THREE.CanvasTexture(cnv);
      }

      // === Chevron texture (minder fel) ===
      function chevronsTex(w = 1024, h = 256) {
        const c = document.createElement("canvas");
        c.width = w;
        c.height = h;
        const ctx = c.getContext("2d");
        ctx.fillStyle = "#444"; // donkergrijs als achtergrond
        ctx.fillRect(0, 0, w, h);

        const colors = [
          "#cc2b2b", // rood (donkerder)
          "#e6b800", // geel (zachter)
          "#2fa64a", // groen (rustiger)
          "#1c90d4", // blauw
          "#4527a0", // paars
          "#f2f2f2", // wit
        ];
        const sw = w / colors.length;
        for (let i = 0; i < colors.length; i++) {
          ctx.save();
          ctx.fillStyle = colors[i];
          ctx.setTransform(1, 0, -0.5, 1, i * sw, 0);
          ctx.fillRect(0, 0, sw + 60, h);
          ctx.restore();
        }

        ctx.strokeStyle = "rgba(0,0,0,.35)";
        ctx.lineWidth = 5;
        ctx.strokeRect(0, 0, w, h);

        const t = new THREE.CanvasTexture(c);
        t.colorSpace = THREE.SRGBColorSpace;
        return t;
      }

      // === Board texture (met tekst placeholders) ===
      function boardTex(info, w = 2048, h = 1024) {
        const c = document.createElement("canvas");
        c.width = w;
        c.height = h;
        const ctx = c.getContext("2d");
        ctx.fillStyle = "#f6f8fb";
        ctx.fillRect(0, 0, w, h);

        ctx.fillStyle = "#0b2236";
        ctx.font = "700 64px system-ui";
        ctx.fillText("Portfolio:", 90, 200);
        ctx.fillText(info.portfolio, 420, 200);
        ctx.fillText("Contact:", 90, 320);
        ctx.fillText(info.contact, 420, 320);
        ctx.fillText("Tech:", 90, 440);
        ctx.fillText(info.tech, 420, 440);

        const tex = new THREE.CanvasTexture(c);
        tex.colorSpace = THREE.SRGBColorSpace;
        return tex;
      }

      // === Clapper ===
      const clapper = new THREE.Group();
      scene.add(clapper);
      clapper.position.set(0, 0.6, 0);

      const boardW = 1.4,
        boardH = 0.8,
        boardD = 0.04;
      const topH = 0.16,
        topD = 0.04;

      // board mesh
      const board = new THREE.Mesh(
        new THREE.BoxGeometry(boardW, boardH, boardD),
        new THREE.MeshStandardMaterial({
          map: boardTex({
            portfolio: "hannelore.design",
            contact: "mail@hannelore.design • @hannelorev",
            tech: "HTML/CSS • JS/Three.js • Figma",
          }),
          roughnessMap: noiseTex(512, 256, 1.6),
          roughness: 0.55,
          metalness: 0.02,
        })
      );
      board.castShadow = true;
      board.receiveShadow = true;
      clapper.add(board);

      // hinge + klep (zelfde breedte als board)
      const hinge = new THREE.Group();
      hinge.position.set(0, boardH / 2 + topH / 2, 0);
      clapper.add(hinge);

      const top = new THREE.Mesh(
        new THREE.BoxGeometry(boardW, topH, topD), // exact even breed
        new THREE.MeshStandardMaterial({
          map: chevronsTex(),
          roughnessMap: noiseTex(512, 128, 1.5),
          roughness: 0.45,
          metalness: 0.05,
        })
      );
      top.position.set(0, 0, 0);
      top.castShadow = true;
      top.receiveShadow = true;
      hinge.add(top);

      // helpers
      const grid = new THREE.GridHelper(10, 20, 0x6666ff, 0x333333);
      scene.add(grid);
      const axes = new THREE.AxesHelper(2);
      scene.add(axes);

      // animate
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      addEventListener("resize", () => {
        renderer.setSize(innerWidth, innerHeight);
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
      });
    </script>
  </body>
</html>
